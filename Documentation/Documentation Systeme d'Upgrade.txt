# Documentation totale â€” SystÃ¨me dâ€™upgrade (end-to-end)

## 0) Ce que le systÃ¨me fait rÃ©ellement (rÃ©sumÃ© exact)

1. Un **GestionnaireLoot** contient des items (id + quantite + nom)
2. Le **Labolo** (menu dâ€™upgrade) lit ce loot et affiche une **grille** de cellules
3. Tu drag une **CelluleUpg** vers un **DepotArme** (slot dâ€™Ã©quipement dâ€™upgrade)
4. Si le drop est valide :

   * le dÃ©pÃ´t â€œaccepteâ€ lâ€™item
   * le loot est **consommÃ©** (pris=1)
   * le Labo refresh sa grille
   * le **GestionnaireUpgradesArmeTir** reÃ§oit `ajouter_upgrade_par_id(id_item, q)`
5. Le gestionnaire applique :

   * sur lâ€™arme courante (groupe `armes_tir`)
   * sur les projectiles (pool + actifs)

---

# 1) Modules du systÃ¨me (TOUS)

## A) `GestionnaireLoot` (Node)

### RÃ´le

* Stocke lâ€™inventaire dâ€™items loot/upgrade.
* Fournit au Labo : la liste des ids et quantitÃ©s.
* Applique la consommation quand un upgrade est â€œprisâ€.

### Ce que tes logs prouvent

* `"[Labolo] Loot attachÃ©: GestionnaireLoot:<Node#...>"`
* `"[Loot] consommer_loot id=... pris=1 reste=..."`

Donc : **le drop dÃ©clenche une consommation**, et **la source des quantitÃ©s est Loot**.

---

## B) `LaboloMenu` / `Labolo` (UI / Menu)

### RÃ´le

* Ouvre/ferme le menu.
* Lit le loot attachÃ©.
* Affiche la grille filtrÃ©e.
* Envoie les drops au dÃ©pÃ´t (et au gestionnaire dâ€™upgrades).

### Logs importants

* `[Labolo] OUVRIR menu / FERMER menu`
* `[Labolo] Grille: total_ids=... affiches=... prefixes=["upg_", "upgrade_"]`
* `[Labolo] DROP OK: slot=TIR id=... pris=1`

### DÃ©tails clÃ©s que tu utilises (trÃ¨s important)

* **Filtrage par prefixes** : `upg_` et `upgrade_`

  * Ã§a veut dire : le Labo ne montre pas tout, il filtre lâ€™inventaire loot.
* Le Labo **refresh la grille** aprÃ¨s chaque drop.

---

## C) `CelluleUpg` (UI draggable)

### RÃ´le

* ReprÃ©sente un item upgrade (id + quantite + nom_item).
* Est draggable.
* Produit un â€œpayloadâ€ de drop.

### Logs

* `[CelluleUpg] drag OK {id_item=..., quantite=..., nom_item=...}`

ğŸ‘‰ ton systÃ¨me de drag & drop ne passe pas juste un id : il passe une structure de data.

---

## D) `DepotArme` (slot de drop)

### RÃ´le

* DÃ©cide si lâ€™objet peut Ãªtre droppÃ© (`can_drop`)
* Connait un â€œslot logiqueâ€ (ici `TIR (ARME TIR)`)
* ReÃ§oit la data dropÃ©e
* Si OK : dÃ©clenche la consommation loot + appel au gestionnaire dâ€™upgrade

### Logs critiques

* `[DepotArme] can_drop=true slot=TIR ... data={id_item=..., quantite=...}`
* `[DepotArme] DROP OK slot=TIR ... id=... q=...`

ğŸ‘‰ **Câ€™est le dÃ©pÃ´t qui valide**, pas le gestionnaire dâ€™upgrade.

---

## E) `UpgradeRegistry`

DÃ©jÃ  dÃ©crit, mais on ajoute un point important :

### RÃ´le â€œrÃ©elâ€ dans ton systÃ¨me

* Il nâ€™est pas juste une liste : câ€™est **la traduction â€œid itemâ€ â†’ â€œeffetâ€**.
* Si `_map` est vide ou pas Ã  jour, ton gestionnaire tombe en fallback manuel.

Tu as : `[UpgradeRegistry] loaded=1`
Donc ton registry ne contient **quâ€™un seul UpgradeData** actuellement (ou un seul valide).

---

## F) `UpgradeData`

DÃ©jÃ  dÃ©crit. Mais point crucial :

### â€œpropâ€ doit matcher EXACTEMENT une propriÃ©tÃ© exportÃ©e

* Sur `ArmeBase`, `ArmeTir`, `Projectile`.
  Sinon : `apply_to()` ne fait rien.

---

## G) `GestionnaireUpgradesArmeTir`

On ajoute ce que tu utilises vraiment :

### EntrÃ©es

* `ajouter_upgrade_par_id(id_item, q)`

  * appelÃ©e depuis le flow Labo â†’ DÃ©pÃ´t

### Stockage

Tu as 2 stockages diffÃ©rents :

* `_upg_stacks` : total global par id (utile debug/stats)
* `_upg_by_slot` : Ã©tat effectif appliquÃ© (slot -> id + stacks)

âš ï¸ TrÃ¨s important :

* Si deux upgrades ont le mÃªme `slot`, **le dernier remplace** lâ€™ancien.
* Donc tu peux avoir `_upg_stacks` qui monte, mais `_upg_by_slot` qui nâ€™applique quâ€™un seul id par slot.

### Application

* `re_appliquer()` : prend la premiÃ¨re arme `armes_tir`
* applique â€œmanuelâ€ puis â€œregistryâ€
* puis applique sur projectiles

---

## H) `ArmeTir` / `ArmeBase`

### Points importants du systÃ¨me rÃ©el

* Lâ€™arme est **instanciÃ©e via loot**, mais Ã§a ne change rien : elle rejoint le groupe `armes_tir` dans `_ready()`.
* Lâ€™arme appelle `upgrades.appliquer_sur_arme(self)` au moment dâ€™attaquer (et aussi sur projectile au spawn).

ğŸ‘‰ Donc mÃªme si `re_appliquer()` nâ€™Ã©tait pas appelÃ©, tu as quand mÃªme une application au moment de tirer. (Ã‡a explique pourquoi ton displayer voit les changements.)

---

## I) `Projectile`

### DÃ©tail important

* Les projectiles poolÃ©s gardent leurs valeurs.
* Si tu modifies des stats projectile aprÃ¨s coup, il faut :

  * soit repasser sur pool + actifs (ce que fait ton gestionnaire)
  * soit au moins modifier au spawn (ce que fait `_prendre_projectile()`)

---

## J) `ArmTirStatsDisplayer` (ton displayer)

### RÃ´le

* Debug â€œpreuveâ€ que les stats changent rÃ©ellement en runtime.
* Dans tes logs :

  * il ne trouve pas lâ€™arme au dÃ©but (normal si arme instanciÃ©e aprÃ¨s)
  * puis il la trouve et lâ€™affiche

Logs :

* `[ArmTirStatsDisplayer] aucune arme dans groupe 'armes_tir'`
* `[ArmTirStatsDisplayer] arme trouvÃ©e ...`

ğŸ‘‰ Ã§a confirme que **ton systÃ¨me de groupes est OK**.

---

# 2) Flux complet exact (avec responsabilitÃ©s)

## 1) Loot â†’ Labo

* Loot attachÃ© au Labo
* Labo filtre `upg_` / `upgrade_`
* affiche items

## 2) Drag CelluleUpg

* cellule fabrique data `{id_item, quantite, nom_item}`

## 3) Drop sur DepotArme

* DepotArme valide can_drop
* DepotArme consomme loot (`pris=1`)
* DepotArme dÃ©clenche appel upgrade

## 4) GestionnaireUpgradesArmeTir reÃ§oit lâ€™ID

* cherche UpgradeData via registry
* si trouvÃ© : stocke par slot et applique
* sinon : fallback manuel if/elif

## 5) Lâ€™arme et projectiles se mettent Ã  jour

* arme : propriÃ©tÃ©s changent
* projectile : pool + actifs changent

---

# 3) Pourquoi tu pensais que â€œÃ§a marche pasâ€ alors que Ã§a marche

Parce que tu avais 2 problÃ¨mes de perception possibles :

1. **Registry loaded=1**

   * donc tes upgrades `upg_degats_tir_1` etc. nâ€™Ã©taient probablement PAS dans le registry â†’ ils passaient en fallback manuel OU ne faisaient rien (si pas fallback).
   * Mais toi tu regardais le rÃ©sultat global en jeu, donc confusion.

2. **slot unique**

   * si plusieurs upgrades partagent le mÃªme slot, tu â€œperdsâ€ un upgrade (remplacÃ©).
   * Toi tu vois â€œjâ€™ai 3 items consommÃ©sâ€, mais lâ€™effet final nâ€™en reflÃ¨te quâ€™un.

3. **hitscan vs projectile**

   * un upgrade â€œvitesse projectileâ€ ne sert Ã  rien si lâ€™arme est en hitscan.

---

# 4) Les Ã©lÃ©ments que jâ€™avais pas documentÃ© au dÃ©part (liste)

* `GestionnaireLoot` (stock + consommation)
* `Labolo` (UI + filtrage prefix + refresh)
* `CelluleUpg` (drag payload)
* `DepotArme` (validation drop, slot, consommation, routage)
* le filtrage `prefixes=["upg_", "upgrade_"]`
* le fait que `pris=1` mÃªme si quantite>1
* le displayer et le timing dâ€™instanciation de lâ€™arme

---

# 5) Check-list â€œÃ§a marche / Ã§a marche pasâ€ (ultra rapide)

## Si tu veux que 100% des upgrades soient data-driven (registry)

Tu dois avoir :

* `UpgradeRegistry.loaded == nombre dâ€™upgrades valides`
* chaque item loot id == upgradeData.id
* chaque upgradeData.prop == vraie propriÃ©tÃ© exportÃ©e
* slots cohÃ©rents (pas tous `"default"` si tu veux cumuler plusieurs effets)

## Si tu veux juste que â€œÃ§a marche maintenantâ€

* displayer te confirme dÃ©jÃ  que dÃ©gÃ¢ts/vitesse changent
* donc ton problÃ¨me nâ€™est pas â€œÃ§a prend pas effetâ€ â†’ câ€™Ã©tait soit :

  * un manque de visibilitÃ©, soit
  * un cas oÃ¹ Ã§a ne changeait pas le gameplay (hitscan etc.)
