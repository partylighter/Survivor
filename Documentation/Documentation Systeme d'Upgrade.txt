# Documentation totale — Système d’upgrade (end-to-end)

## 0) Ce que le système fait réellement (résumé exact)

1. Un GestionnaireLoot contient des items (id + quantite + nom)
2. Le Labolo (menu d’upgrade) lit ce loot et affiche une grille de cellules
3. Tu drag une CelluleUpg vers un DepotArme (slot d’équipement d’upgrade)
4. Si le drop est valide :

   * le dépôt accepte l’item
   * le loot est consommé (pris=1)
   * le Labo refresh sa grille
   * le gestionnaire d’upgrades du slot reçoit ajouter_upgrade_par_id(id_item, q)
5. Le gestionnaire applique :

   * sur l’arme courante (groupe armes_tir / armes_contact)
   * sur les projectiles (pool + actifs) pour Tir
   * sur l’arme + hitbox pour Contact

---

# 1) Modules du système (TOUS)

## A) GestionnaireLoot (Node)

### Rôle

* Stocke l’inventaire d’items loot/upgrade.
* Fournit au Labo la liste des ids et quantités.
* Applique la consommation quand un upgrade est pris.

### Ce que tes logs prouvent

* "[Labolo] Loot attaché: GestionnaireLoot:<Node#...>"
* "[Loot] consommer_loot id=... pris=1 reste=..."

Donc : le drop déclenche une consommation, et la source des quantités est Loot.

---

## B) LaboloMenu / Labolo (UI / Menu)

### Rôle

* Ouvre/ferme le menu.
* Lit le loot attaché.
* Affiche la grille filtrée.
* Reçoit les drops des dépôts et route vers le bon gestionnaire d’upgrades.

### Logs importants

* [Labolo] OUVRIR menu / FERMER menu
* [Labolo] Grille: total_ids=... affiches=... prefixes=["upg_", "upgrade_"]
* [Labolo] DROP OK: slot=... id=... pris=1

### Détails clés

* Filtrage par prefixes : upg_ et upgrade_
* Le Labo refresh la grille après chaque drop.
* Routage par type_emplacement :

  * slot TIR → groupe upg_arme_tir → GestionnaireUpgradesArmeTir
  * slot CONTACT → groupe upg_arme_contact → GestionnaireUpgradesArmeContact

---

## C) CelluleUpg (UI draggable)

### Rôle

* Représente un item upgrade (id + quantite + nom_item).
* Est draggable.
* Produit un payload de drop.

### Logs

* [CelluleUpg] drag OK {id_item=..., quantite=..., nom_item=...}

Le drag & drop passe une structure de data, pas juste un id.

---

## D) DepotArme (slot de drop)

### Rôle

* Décide si l’objet peut être droppé (can_drop)
* Connait un slot logique (TIR ou CONTACT)
* Reçoit la data droppée
* Si OK : déclenche consommation loot + appel au gestionnaire d’upgrade via le Labo

### Logs critiques

* [DepotArme] can_drop=true slot=... data={id_item=..., quantite=...}
* [DepotArme] DROP OK slot=... id=... q=...

C’est le dépôt qui valide, pas le gestionnaire d’upgrade.

---

## E) UpgradeRegistry

### Rôle réel

* Traduction id item → UpgradeData (effet data-driven)
* Si _map est vide ou pas à jour, le gestionnaire doit fallback (manuel) ou ne fait rien.

Log typique :

* [UpgradeRegistry] loaded=...

---

## F) UpgradeData

### Point crucial

* prop doit matcher exactement une propriété exportée sur la cible.
* Si prop ne matche pas : apply_to() ne fait rien.

Cibles typiques :

* ArmeBase
* ArmeTir
* Projectile
* ArmeContact
* HitBoxContact

---

## G) GestionnaireUpgradesArmeTir

### Entrées

* ajouter_upgrade_par_id(id_item, q)

### Stockage

* _upg_stacks : total global par id
* _upg_by_slot : état effectif appliqué (slot -> id + stacks)

Règle importante

* Si deux upgrades partagent le même slot, le dernier remplace l’ancien dans _upg_by_slot.

### Application

* re_appliquer() :

  * prend une arme du groupe armes_tir
  * applique manuel puis registry
  * applique aussi aux projectiles (pool + actifs)

---

## H) ArmeTir / ArmeBase

### Points importants

* Arme instanciée via loot : elle rejoint armes_tir dans _ready().
* L’arme applique ses upgrades au moment de tirer (et/ou au spawn projectile selon ton implémentation).

---

## I) Projectile

### Détail important

* Les projectiles poolés gardent leurs valeurs.
* Si tu modifies des stats projectile après coup :

  * soit tu patches pool + actifs (ce que fait le gestionnaire)
  * soit tu appliques au spawn (dans _prendre_projectile()).

---

## J) ArmTirStatsDisplayer

### Rôle

* Preuve runtime que les stats changent.
* Trouve arme via groupe armes_tir et upgrades via groupe upg_arme_tir.

Logs typiques

* [ArmTirStatsDisplayer] aucune arme dans groupe 'armes_tir'
* [ArmTirStatsDisplayer] arme trouvée ...

---

## K) GestionnaireUpgradesArmeContact

### Rôle

* Stocke les upgrades contact par id (stacks).
* Convertit un id en modifs concrètes (degats, cooldown, recul, etc.).
* Applique sur :

  * ArmeContact (stats héritées de ArmeBase)
  * HitBoxContact (collision_mask/layer + monitoring/disabled si activé)

### Entrées

* ajouter_upgrade_par_id(id_item, q)
* re_appliquer()

### Stockage

* _stacks : total par id
* optionnel : _upg_by_slot si tu veux une logique de slot unique côté contact

### Application

* appliquer_sur(arme_contact) :

  * capture base si besoin
  * revert base
  * applique les flags mod_* via _patch()
  * applique aussi sur hitbox si trouvée

Comportement important

* Sans re_appliquer() immédiat, l’effet peut n’être visible qu’au moment de l’attaque (si tu ne refresh pas l’arme au drop).

---

## L) ArmeContact / ArmeBase

### Points importants

* ArmeContact rejoint armes_contact dans _ready().
* Au moment d’attaquer :

  * cherche upgrades (groupe upg_arme_contact)
  * applique upgrades.appliquer_sur(self)
  * configure la hitbox avec degats/recul_force/porteur
  * active la hitbox pendant duree_active_s
  * cooldown via timer

---

## M) HitBoxContact

### Rôle

* Reçoit la config d’attaque :

  * configurer(degats, recul_force, porteur)
  * activer_pendant(duree_active_s)
* Peut recevoir des modifs collision/monitoring/disabled depuis le gestionnaire upgrades contact.

---

## N) ArmContactStatsDisplayer

### Rôle

* Preuve runtime pour le contact.
* Affiche :

  * stats actuelles de l’arme contact (degats, cooldown, duree_active, recul)
  * état des paramètres du gestionnaire contact (si tu lis directement les vars exportées)

---

# 2) Flux complet exact (avec responsabilités)

## 1) Loot → Labo

* Loot attaché au Labo
* Labo filtre upg_ / upgrade_
* Affiche les items

## 2) Drag CelluleUpg

* La cellule fabrique data {id_item, quantite, nom_item}

## 3) Drop sur DepotArme

* DepotArme valide can_drop
* DepotArme fait consommer_loot(id_item, 1) → pris=1
* DepotArme déclenche le Labo qui appelle le bon gestionnaire selon le slot

## 4) GestionnaireUpgrades reçoit l’ID

* slot TIR → GestionnaireUpgradesArmeTir.ajouter_upgrade_par_id + re_appliquer
* slot CONTACT → GestionnaireUpgradesArmeContact.ajouter_upgrade_par_id + re_appliquer (si tu veux effet immédiat)

## 5) Les éléments se mettent à jour

* Tir :

  * arme : propriétés changent
  * projectiles : pool + actifs changent
* Contact :

  * arme : propriétés changent
  * hitbox : paramètres collision/monitoring/disabled changent si activés
  * application gameplay garantie au moment de l’attaque via hitbox.configurer()

---

# 3) Pourquoi tu pensais que ça marche pas alors que ça marche

1. Registry loaded faible

* Si UpgradeRegistry.loaded est bas, beaucoup d’ids passent en fallback manuel ou ne font rien.
* Tu consommes des items mais l’effet attendu ne correspond pas.

2. Slot unique (Tir)

* Tu consommes plusieurs items mais un seul est effectif si même slot.

3. Hitscan vs projectile (Tir)

* Upgrades projectile inutiles si arme hitscan.

4. Contact appliqué au mauvais moment

* Si tu n’appliques pas au drop, tu ne vois rien tant que tu n’attaques pas.
* Le vrai moment gameplay côté contact, c’est quand la hitbox est configurée et activée.

---

# 4) Les éléments manquants au départ (liste)

* GestionnaireLoot (stock + consommation)
* Labolo (UI + filtrage prefix + refresh + routage)
* CelluleUpg (payload drag)
* DepotArme (validation drop, slot, consommation)
* Filtrage prefixes=["upg_", "upgrade_"]
* pris=1 même si quantite > 1
* Displayer + timing d’apparition des armes
* GestionnaireUpgradesArmeContact + différence “appliquer au drop” vs “appliquer à l’attaque”
* HitBoxContact comme point d’impact gameplay

---

# 5) Check-list ça marche / ça marche pas (ultra rapide)

## Si tu veux 100% data-driven (registry)

* UpgradeRegistry.loaded == nombre d’upgrades valides attendus
* loot id == UpgradeData.id
* UpgradeData.prop == vraie propriété exportée sur la cible
* slots cohérents (pas tous "default" si tu veux cumuler)
* cibles correctes (ArmeTir/Projectile vs ArmeContact/HitBoxContact)

## Si tu veux juste que ça marche maintenant

* Le Labo consomme bien (pris=1)
* Le bon gestionnaire est trouvé via groupe (upg_arme_tir / upg_arme_contact)
* Tir :

  * re_appliquer() met à jour arme + projectiles
* Contact :

  * re_appliquer() met à jour l’arme immédiatement ou, au minimum, attaque() applique avant hitbox.configurer()
